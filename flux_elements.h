//advection_diffusion_reaction_flux_elements.h starts  here

//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//    Version 1.0; svn revision $LastChangedRevision: 1097 $
//LIC//
//LIC// $LastChangedDate: 2015-12-17 11:53:17 +0000 (Thu, 17 Dec 2015) $
//LIC// 
//LIC// Copyright (C) 2006-2016 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
// Header file for elements that are used to apply prescribed flux
// boundary conditions to the Advection Diffusion equations
#ifndef OOMPH_ADV_DIFF_REACT_FLUX_ELEMENTS_HEADER
#define OOMPH_ADV_DIFF_REACT_FLUX_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// oomph-lib ncludes
#include "generic/Qelements.h"

namespace oomph
{

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////




//======================================================================
/// \short A class for elements that allow the imposition of an 
/// applied flux on the boundaries of Advection Diffusion elements.
/// The element geometry is obtained from the  FaceGeometry<ELEMENT> 
/// policy class.
//======================================================================
 template <class ELEMENT>
 class AdvectionDiffusionReactionFluxElement : public virtual FaceGeometry<ELEMENT>, 
					       public virtual FaceElement
 {
 
 public:


  /// \short Function pointer to the prescribed-flux function fct(x,f(x)) -- 
  /// x is a Vector! 
  typedef void (*AdvectionDiffusionReactionPrescribedFluxFctPt)
  (const Vector<double>& x, const Vector<double>& C, Vector<double>& flux);


  /// \short Constructor, takes the pointer to the "bulk" element
  /// and the index of the face to be created
  AdvectionDiffusionReactionFluxElement(FiniteElement* const &bulk_el_pt, 
					const int &face_index);


  ///\short  Broken empty constructor
  AdvectionDiffusionReactionFluxElement()
  {
   throw OomphLibError(
    "Don't call empty constructor for AdvectionDiffusionReactionFluxElement",
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
  }

  /// Broken copy constructor
  AdvectionDiffusionReactionFluxElement(const AdvectionDiffusionReactionFluxElement& dummy) 
  { 
   BrokenCopy::broken_copy("AdvectionDiffusionReactionFluxElement");
  } 
 
  /// Broken assignment operator
  void operator=(const AdvectionDiffusionReactionFluxElement&) 
  {
   BrokenCopy::broken_assign("AdvectionDiffusionReactionFluxElement");
  }

  /// Access function for the prescribed-flux function pointer
  AdvectionDiffusionReactionPrescribedFluxFctPt& flux_fct_pt() {return Flux_fct_pt;}


  /// Add the element's contribution to its residual vector
  inline void fill_in_contribution_to_residuals(Vector<double> &residuals)
  {
   //Call the generic residuals function with flag set to 0
   //using a dummy matrix
   fill_in_generic_residual_contribution_adv_diff_react_flux(
    residuals,GeneralisedElement::Dummy_matrix,0);
  }


  /// \short Add the element's contribution to its residual vector and 
  /// its Jacobian matrix
  inline void fill_in_contribution_to_jacobian(Vector<double> &residuals,
					       DenseMatrix<double> &jacobian)
  {
   //Call the generic routine with the flag set to 1
   fill_in_generic_residual_contribution_adv_diff_react_flux(
    residuals,jacobian,1);
  }

  /// Specify the value of nodal zeta from the face geometry
  /// \short The "global" intrinsic coordinate of the element when
  /// viewed as part of a geometric object should be given by
  /// the FaceElement representation, by default (needed to break
  /// indeterminacy if bulk element is SolidElement)
  double zeta_nodal(const unsigned &n, const unsigned &k,           
		    const unsigned &i) const 
  {return FaceElement::zeta_nodal(n,k,i);}     
 
  /// \short Output function -- forward to broken version in FiniteElement
  /// until somebody decides what exactly they want to plot here...
  void output(std::ostream &outfile) {FiniteElement::output(outfile);}

  /// \short Output function -- forward to broken version in FiniteElement
  /// until somebody decides what exactly they want to plot here...
  void output(std::ostream &outfile, const unsigned &nplot)
  {FiniteElement::output(outfile,nplot);}

 protected:

  /// \short Function to compute the shape and test functions and to return 
  /// the Jacobian of mapping between local and global (Eulerian)
  /// coordinates
  inline double shape_and_test(const Vector<double> &s, Shape &psi, Shape &test)
   const
  {
   //Find number of nodes
   unsigned n_node = nnode();

   //Get the shape functions
   shape(s,psi);

   //Set the test functions to be the same as the shape functions
   for(unsigned i=0;i<n_node;i++) {test[i] = psi[i];}

   //Return the value of the jacobian
   return J_eulerian(s);
  }


  /// \short Function to compute the shape and test functions and to return 
  /// the Jacobian of mapping between local and global (Eulerian)
  /// coordinates
  inline double shape_and_test_at_knot(const unsigned &ipt,
				       Shape &psi, Shape &test)
   const
  {
   //Find number of nodes
   unsigned n_node = nnode();

   //Get the shape functions
   shape_at_knot(ipt,psi);

   //Set the test functions to be the same as the shape functions
   for(unsigned i=0;i<n_node;i++) {test[i] = psi[i];}

   //Return the value of the jacobian
   return J_eulerian_at_knot(ipt);
  }



  /// \short Function to calculate the prescribed flux at a given spatial
  /// position
  void get_flux(const Vector<double>& x,
		const Vector<double>& C,
		Vector<double>& flux)
  {
   //If the function pointer is zero return zero
   if(Flux_fct_pt == 0)
   {
    unsigned  n_flux=Nreagent;
    for (unsigned i=0;i<n_flux;i++)
    {
     flux[i]=0.0;
    }
   }
   //Otherwise call the function
   else
   {
    (*Flux_fct_pt)(x,C,flux);
   }
  }

  /// \short Function to calculate the prescribed flux at a given spatial
  /// position
  void get_dfluxdC(const Vector<double>& x,
		   const Vector<double>& C,
		   DenseMatrix<double>& dfluxdC)
  {
   //If the function pointer is zero return zero
   if(Flux_fct_pt == 0)
   {
    unsigned  n_flux=Nreagent;
    for (unsigned i=0;i<n_flux;i++)
    {
     for(unsigned i2=0;i2<n_flux;i2++)
     {
      dfluxdC(i,i2)=0.0;
     }
    }
   }
   //Otherwise get the derivative
   else
   {
    unsigned n_flux=Nreagent;
    //Local copy of the unknowns
    Vector<double> C_local=C;
    //Initialise variables for FD
    Vector<double> flux(Nreagent,0.0);
    Vector<double> flux_plus_C(Nreagent,0.0);
    Vector<double> flux_minus_C(Nreagent,0.0);

    //General small FD step
    const double fd_step = GeneralisedElement::Default_fd_jacobian_step;

    //Loop over the reagents
    for(unsigned p=0;p<n_flux;p++)
    {
     //Store the old value
     double old_var_C=C_local[p];
     //Increment the value
     C_local[p]+=fd_step;
     //Get the new values
     (*Flux_fct_pt)(x,C_local,flux_plus_C);

     //Reset the value
     C_local[p]=old_var_C;
     //Decrement the value
     C_local[p]-=fd_step;
     //Get the new values
     (*Flux_fct_pt)(x,C_local,flux_minus_C);

     //For each equation (each flux term)
     for(unsigned r=0;r<n_flux;r++)
     {
      //FD equation for dRdC
      dfluxdC(r,p) = (flux_plus_C[r] - flux_minus_C[r])/(2.0*fd_step);
     }

     //Reset the value
     C_local[p]=old_var_C;
    }//End loop over the reagents
   }
  }

 private:


  /// \short Add the element's contribution to its residual vector.
  /// flag=1(or 0): do (or don't) compute the Jacobian as well. 
  void fill_in_generic_residual_contribution_adv_diff_react_flux(
   Vector<double> &residuals, DenseMatrix<double> &jacobian, 
   unsigned flag);
 
  /// Function pointer to the (global) prescribed-flux function
  AdvectionDiffusionReactionPrescribedFluxFctPt Flux_fct_pt;

  /// The spatial dimension of the problem
  unsigned Dim;

  /// The index at which the unknown is stored at the nodes
  unsigned U_index_adv_diff_react;

  unsigned Nreagent;

 }; 





///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////



//===========================================================================
/// \short Constructor, takes the pointer to the "bulk" element and the index
/// of the face to be created 
//===========================================================================
 template<class ELEMENT>
 AdvectionDiffusionReactionFluxElement<ELEMENT>::
 AdvectionDiffusionReactionFluxElement(FiniteElement* const &bulk_el_pt, 
				       const int &face_index) : 
  FaceGeometry<ELEMENT>(), FaceElement()
 {  
  // Let the bulk element build the FaceElement, i.e. setup the pointers 
  // to its nodes (by referring to the appropriate nodes in the bulk
  // element), etc.
  bulk_el_pt->build_face_element(face_index,this);
 
#ifdef PARANOID
  {
   //Check that the element is not a refineable 3d element
   ELEMENT* elem_pt = dynamic_cast<ELEMENT*>(bulk_el_pt);
   //If it's three-d
   if(elem_pt->dim()==3)
   {
    //Is it refineable
    RefineableElement* ref_el_pt=dynamic_cast<RefineableElement*>(elem_pt);
    if(ref_el_pt!=0)
    {
     if (this->has_hanging_nodes())
     {
      throw OomphLibError(
       "This flux element will not work correctly if nodes are hanging\n",
       OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
     }
    }
   }
  }
#endif

  // Initialise the prescribed-flux function pointer to zero
  Flux_fct_pt = 0;
 
  // Extract the dimension of the problem from the dimension of 
  // the first node
  Dim = this->node_pt(0)->ndim();

  //Get the number of reagents at node 0 (same for every node)
  Nreagent=bulk_el_pt->required_nvalue(0);

  //Set up U_index_adv_diff_react. Initialise to zero, which probably won't change
  //in most cases, oh well, the price we pay for generality
  U_index_adv_diff_react = 0;

  //Hollyyyyy: error checking that I shouldn't need
  //It would make it much harder to implement flux elements
 
  //Cast to the appropriate AdvectionDiffusionReactionEquation so that we can
  //find the index at which the variable is stored
  //We assume that the dimension of the full problem is the same
  //as the dimension of the node, if this is not the case you will have
  //to write custom elements, sorry
  /*switch(Dim)
    {
    //One dimensional problem
    case 1:
    {
    AdvectionDiffusionReactionEquations<1>* eqn_pt = 
    dynamic_cast<AdvectionDiffusionReactionEquations<1>*>(bulk_el_pt);
    //If the cast has failed die
    if(eqn_pt==0)
    {
    std::string error_string =
    "Bulk element must inherit from AdvectionDiffusionReactionEquations.";
    error_string += 
    "Nodes are one dimensional, but cannot cast the bulk element to\n";
    error_string += "AdvectionDiffusionReactionEquations<1>\n.";
    error_string += 
    "If you desire this functionality, you must implement it yourself\n";
     
    throw OomphLibError(
    error_string,
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
    }
    //Otherwise read out the value
    else
    {
    //Read the index from the (cast) bulk element
    U_index_adv_diff_react = eqn_pt->u_index_adv_diff_react();
    }
    }
    break;
  
    //Two dimensional problem
    case 2:
    {
    AdvectionDiffusionReactionEquations<2>* eqn_pt = 
    dynamic_cast<AdvectionDiffusionReactionEquations<2>*>(bulk_el_pt);
    //If the cast has failed die
    if(eqn_pt==0)
    {
    std::string error_string =
    "Bulk element must inherit from AdvectionDiffusionReactionEquations.";
    error_string += 
    "Nodes are two dimensional, but cannot cast the bulk element to\n";
    error_string += "AdvectionDiffusionReactionEquations<2>\n.";
    error_string += 
    "If you desire this functionality, you must implement it yourself\n";
     
    throw OomphLibError(
    error_string,
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
    }
    else
    {
    //Read the index from the (cast) bulk element.
    U_index_adv_diff_react = eqn_pt->u_index_adv_diff_react();
    }
    }
    break;
  
    //Three dimensional problem
    case 3:
    {
    AdvectionDiffusionReactionEquations<3>* eqn_pt = 
    dynamic_cast<AdvectionDiffusionReactionEquations<3>*>(bulk_el_pt);
    //If the cast has failed die
    if(eqn_pt==0)
    {
    std::string error_string =
    "Bulk element must inherit from AdvectionDiffusionReactionEquations.";
    error_string += 
    "Nodes are three dimensional, but cannot cast the bulk element to\n";
    error_string += "AdvectionDiffusionReactionEquations<3>\n.";
    error_string += 
    "If you desire this functionality, you must implement it yourself\n";
     
    throw OomphLibError(
    error_string,
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
     
    }
    else
    {
    //Read the index from the (cast) bulk element.
    U_index_adv_diff_react = eqn_pt->u_index_adv_diff_react();
    }
    }
    break;
  
    //Any other case is an error
    default:
    std::ostringstream error_stream; 
    error_stream <<  "Dimension of node is " << Dim 
    << ". It should be 1,2, or 3!" << std::endl;
   
    throw OomphLibError(
    error_stream.str(),
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
    break;
    }*/
 }


//===========================================================================
/// Compute the element's residual vector and the Jacobian matrix.
//===========================================================================
 template<class ELEMENT>
 void AdvectionDiffusionReactionFluxElement<ELEMENT>::
 fill_in_generic_residual_contribution_adv_diff_react_flux(
  Vector<double> &residuals, 
  DenseMatrix<double> &jacobian, 
  unsigned flag)
 {

  //Hollyyyy - the loops may need to change when we're in 2D - why
  //aren't the loops the same as the jacobian calculation in bulk?
  //interpolated_c should be calculated within a loop over the nodes, surely?
  //look at the bulk_element calculation of interpolated_c, why is the
  //calculation of it here different?
  //This method was taken from AD flux elements
  
  //Find out how many nodes there are
  const unsigned n_node = nnode();
  
  //Set up memory for the shape and test functions
  Shape psif(n_node), testf(n_node);
 
  //Set the value of n_intpt
  const unsigned n_intpt = integral_pt()->nweight();

  unsigned n_flux=Nreagent;
 
  Vector<unsigned> flux_nodal_index(n_flux);
  for (unsigned i=0;i<n_flux;i++)
  {
   flux_nodal_index[i]=i;
  }

  //Set the Vector to hold local coordinates
  Vector<double> s(Dim-1);
 
  //Integers used to store the local equation number and local unknown
  //indices for the residuals and jacobians
  int local_eqn=0;
  int local_unknown=0;

  ELEMENT* bulk_el_pt=dynamic_cast<ELEMENT*>(this->bulk_element_pt());

  // Locally cache the index at which the variable is stored
  //const unsigned u_index_adv_diff_react = U_index_adv_diff_react;

  //Loop over the integration points
  //--------------------------------
  for(unsigned ipt=0;ipt<n_intpt;ipt++)
  {
 
   //Assign values of s
   for(unsigned i=0;i<(Dim-1);i++) {s[i] = integral_pt()->knot(ipt,i);}
   
   //Get the integral weight
   double w = integral_pt()->weight(ipt);
   
   //Find the shape and test functions and return the Jacobian
   //of the mapping
   double J = shape_and_test(s,psif,testf);
   
   //Premultiply the weights and the Jacobian
   double W = w*J;
   
   //Need to find position to feed into flux function
   Vector<double> interpolated_x(Dim,0.0);
   
   //Set the Vector to hold local coordinates (bulk)
   Vector<double> s_bulk(Dim,0.0);
   
   //Get the local coord in the respective Bulk element.
   this->get_local_coordinate_in_bulk(s,s_bulk);

   //Vector to hold the unknowns from the bulk element
   Vector<double> interpolated_c(Nreagent,0.0);
   
   //Calculate position
   //Loop over nodes
   for(unsigned l=0;l<n_node;l++) 
   {
    //Loop over coordinate directions
    for(unsigned i=0;i<Dim;i++)
    {
     interpolated_x[i] += nodal_position(l,i)*psif[l];
    }
   }
   
   //Loop over the reagents and get C
   for(unsigned r=0;r<Nreagent;r++)
   {
    interpolated_c[r]= bulk_el_pt->interpolated_c_adv_diff_react(s_bulk,r);
   }
   
   //Get the imposed flux
   Vector<double> flux(Nreagent,0.0);
   get_flux(interpolated_x,interpolated_c,flux);

   //Get the flux derivative wrt the reagents
   DenseMatrix<double> dfluxdC_FD(Nreagent,Nreagent,0.0);
   get_dfluxdC(interpolated_x,interpolated_c,dfluxdC_FD);
 
   //Now add to the appropriate equations
   for(unsigned i=0;i<n_flux;i++)
   {
  
    //Loop over the test functions
    for(unsigned l=0;l<n_node;l++)
    {
   
     //Set the local equation number
     local_eqn = nodal_local_eqn(l,flux_nodal_index[i]);
    
     /*IF it's not a boundary condition*/
     if(local_eqn >= 0)
     {
      //Add the prescribed flux terms
      //Multiplied by the 'diffusivity' in the demo driver
      //because concentration diffusivity \neq D[0]
      residuals[local_eqn] += flux[i]*testf[l]*W;

      
      // Imposed traction doesn't depend upon the solution, 
      // --> the Jacobian is always zero, so no Jacobian
      // terms are required
      //Hollyyyy - flux depends on the concentrations so there
      //will be a non-zero Jacobian
      //Loop over test functions again
      
      if (flag)
      {
       for(unsigned l2=0;l2<n_node;l2++)
       {
	//Loop over the reagents again
	for(unsigned i2=0;i2<n_flux;i2++)
	{
	 //Set the number of the unknown
	 local_unknown=nodal_local_eqn(l2,flux_nodal_index[i2]);

	 //If at a non-zero degree of freedom add in the entry
	 if(local_unknown >= 0)
	 {
	  //If there is no flux function set
	  if(Flux_fct_pt==0)
	  {
	   dfluxdC_FD(i,i2)=0.0;
	  }
	  //Hollyyyyy
	  //We don't have the option to add a user-specified
	  //flux derivative.Maybe add it in later
	  else
	  {
	   jacobian(local_eqn,local_unknown)+=dfluxdC_FD(i,i2)*psif(l2)
	    *testf(l)*W;
	  }
	 }
	
	}//End loop over reagents i2
       }// End loop over test functions l2
      }
      
     }
    }//End loop over test functions l
   }//End loop over fluxes i
  }//End loop over integration points
 }

}


#endif
